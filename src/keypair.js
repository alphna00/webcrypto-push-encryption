// Copyright 2016 Peter Beverloo. All rights reserved.
// Use of this source code is governed by the MIT license, a copy of which can
// be found in the LICENSE file.

const base64UrlToUint8Array = require('./util').base64UrlToUint8Array;
const uint8ArrayToBase64Url = require('./util').uint8ArrayToBase64Url;

// Length, in bytes, of a P-256 field element. Expected format of the private key.
const PRIVATE_KEY_BYTES = 32;

// Length, in bytes, of a P-256 public key in uncompressed EC form per SEC 2.3.3. This sequence must
// start with 0x04. Expected format of the public key.
const PUBLIC_KEY_BYTES = 65;

// Class representing a NIST P-256 Key Pair. A private/public key-pair can be generated by calling
// the KeyPair.generate() method, or a key-pair (in which the private key is optional) can be
// imported by calling KeyPair.import().
//
// The implementation converts to and from JWK at various places to work around the fact that
// working with raw ECDH keying material is not commonly available in Web browsers.
class KeyPair {
  constructor(publicKey, privateKey) {
    this.publicKey_ = publicKey;
    this.privateKey_ = privateKey;
  }

  // Returns a promise with the P-256 KeyPair instance that will resolve when it has been generated.
  static generate() {
    return Promise.resolve().then(() => {
      return crypto.subtle.generateKey({ name: 'ECDH', namedCurve: 'P-256' },
                                       true /* extractable */, ['deriveBits']);

    }).then(keys => new KeyPair(keys.publicKey, keys.privateKey));
  }

  // Returns a promise with the P-256 KeyPair instance that will resolve when the |publicKey| and,
  // when given, the |privateKey| have been verified and imported. Both |publicKey| and |privateKey|
  // are expected to be ArrayBuffers, wherein |publicKey| contains the 65-byte uncompressed EC
  // points and the |privateKey| contains the 32-byte private value.
  static import(publicKey, privateKey) {
    return Promise.resolve().then(() => {
      if (!(publicKey instanceof ArrayBuffer) && !(publicKey instanceof Uint8Array))
        throw new Error('The publicKey is expected to be an ArrayBuffer.');

      if (publicKey.byteLength != PUBLIC_KEY_BYTES)
        throw new Error('The publicKey is expected to be ' + PUBLIC_KEY_BYTES + ' bytes.');

      const publicBuffer = new Uint8Array(publicKey);
      if (publicBuffer[0] != 0x04)
        throw new Error('The publicKey is expected to start with an 0x04 byte.');

      let jwk = {
        kty: 'EC',
        crv: 'P-256',
        x: uint8ArrayToBase64Url(publicBuffer, 1, 33),
        y: uint8ArrayToBase64Url(publicBuffer, 33, 65),
        ext: true
      };

      let privatePromise = Promise.resolve(null);
      let publicPromise = crypto.subtle.importKey('jwk', jwk, { name: 'ECDH', namedCurve: 'P-256' },
                                                  true /* extractable */, []);

      if (privateKey) {
        if (!(privateKey instanceof ArrayBuffer) && !(privateKey instanceof Uint8Array))
          throw new Error('The privateKey is expected to be an ArrayBuffer.');

        if (privateKey.byteLength != PRIVATE_KEY_BYTES) {
          throw new Error('The privateKey is expected to be ' + PRIVATE_KEY_BYTES +' bytes.');
        }

        jwk.d = uint8ArrayToBase64Url(new Uint8Array(privateKey));

        privatePromise = crypto.subtle.importKey('jwk', jwk, { name: 'ECDH', namedCurve: 'P-256' },
                                                  true /* extractable */, ['deriveBits']);
      }

      return Promise.all([ publicPromise, privatePromise ]);

    }).then(([publicKey, privateKey]) => new KeyPair(publicKey, privateKey));
  }

  // Returns a promise that will be resolved with an ArrayBuffer containing the 32-byte shared
  // secret between |this| and |peerKeyPair|. |this| must have both the public and private key set,
  // whereas only the public key is required for |peerKeyPair|.
  deriveSharedSecret(peerKeyPair) {
    return Promise.resolve().then(() => {
      if (!this.privateKey_)
        throw new Error('The private key must be known when deriving the shared secret.');

      if (!(peerKeyPair instanceof KeyPair))
        throw new Error('The peerKeyPair must be a KeyPair instance.');

      const algorithm = { name: 'ECDH', namedCurve: 'P-256', public: peerKeyPair.publicKey };

      return crypto.subtle.deriveBits(algorithm, this.privateKey_, 256);
    });
  }

  // Gets the CryptoKey containing the public key of this key pair.
  get publicKey() { return this.publicKey_; }

  // Returns a promise that will be resolved with an ArrayBuffer containing the pair's public key in
  // uncompressed EC form, a 65-byte sequence containing two P-256 field elements.
  exportPublicKey() {
    return crypto.subtle.exportKey('jwk', this.publicKey_).then(jwk => {
      const x = base64UrlToUint8Array(jwk.x);
      const y = base64UrlToUint8Array(jwk.y);

      let publicKey = new Uint8Array(65);
      publicKey.set([0x04], 0);
      publicKey.set(x, 1);
      publicKey.set(y, 33);

      return publicKey;
    });
  }

  // Gets the CryptoKey containing the private key of this key pair.
  get privateKey() { return this.privateKey_; }

  // Returns a promise that will be resolved with an ArrayBuffer containing the pair's private key,
  // which is a 32-byte long P-256 field element.
  exportPrivateKey() {
    return crypto.subtle.exportKey('jwk', this.privateKey_).then(jwk =>
        base64UrlToUint8Array(jwk.d));
  }
};

module.exports = KeyPair;
